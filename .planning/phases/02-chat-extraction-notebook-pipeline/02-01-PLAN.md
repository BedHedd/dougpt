---
phase: 02-chat-extraction-notebook-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - 02-worktrees/chat-extraction/pyproject.toml
  - 02-worktrees/chat-extraction/chat-extraction.py
  - 02-worktrees/chat-extraction/chat_pipeline.py
  - 00-supporting-files/data/chat-extraction/
autonomous: true
requirements:
  - CHAT-01
  - CHAT-02
user_setup:
  - service: huggingface
    why: "Enable optional local diarization with pyannote/WhisperX when available"
    env_vars:
      - name: HUGGINGFACE_TOKEN
        source: "Hugging Face Settings -> Access Tokens"
must_haves:
  truths:
    - "User can run one notebook path to extract audio from a local video file."
    - "User can run batch mode and failed extractions are logged while remaining files continue."
    - "User gets reusable transcript JSON with segment timestamps, word timestamps when available, and speaker labels when diarization is feasible."
  artifacts:
    - path: "02-worktrees/chat-extraction/chat_pipeline.py"
      provides: "Deterministic extraction and transcription stage functions"
      contains: "extract_audio_batch"
    - path: "02-worktrees/chat-extraction/chat-extraction.py"
      provides: "Notebook cells for input selection, stage execution, and checkpoint file paths"
      contains: "audio -> transcript stage calls"
    - path: "00-supporting-files/data/chat-extraction/transcripts"
      provides: "Reusable transcript artifacts"
      contains: "*.json"
  key_links:
    - from: "02-worktrees/chat-extraction/chat-extraction.py"
      to: "02-worktrees/chat-extraction/chat_pipeline.py"
      via: "Notebook cell imports and calls stage helpers"
      pattern: "from chat_pipeline import"
    - from: "02-worktrees/chat-extraction/chat_pipeline.py"
      to: "ffmpeg"
      via: "subprocess extraction command"
      pattern: "ffmpeg"
    - from: "02-worktrees/chat-extraction/chat_pipeline.py"
      to: "faster_whisper"
      via: "local ASR transcription"
      pattern: "WhisperModel"
---

<objective>
Build the notebook's deterministic input, extraction, and transcription backbone so a local run can reliably produce reusable artifacts before segmentation.

Purpose: Satisfies CHAT-01 and CHAT-02 with resumable, batch-safe foundations that prevent rework and preserve intermediate outputs.
Output: Stage helpers, notebook wiring, and transcript checkpoint files under `00-supporting-files/data/chat-extraction/`.
</objective>

<execution_context>
@/home/bedhedd/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bedhedd/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-extraction-notebook-pipeline/02-CONTEXT.md
@.planning/phases/02-chat-extraction-notebook-pipeline/02-RESEARCH.md
@02-worktrees/chat-extraction/chat-extraction.py
@02-worktrees/chat-extraction/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stage helper module and extraction artifacts contract</name>
  <files>02-worktrees/chat-extraction/chat_pipeline.py, 02-worktrees/chat-extraction/chat-extraction.py</files>
  <action>Create `chat_pipeline.py` with path-anchor discovery (locate `00-supporting-files`), input discovery for single-file and batch modes, and deterministic ffmpeg audio extraction defaults (mono 16k, storage-balanced codec). Implement extraction output layout at `00-supporting-files/data/chat-extraction/{audio,logs,runs}` and enforce batch failure policy: skip failed file, append structured failure log entry, continue. In notebook cells, wire controls for single/batch mode and default sample input `large-files/Doug and Twitch Chat TAKE OVER EUROPE-VpmmuHlLPM0.mkv` while still accepting any ffmpeg-decodable source.</action>
  <verify>From `02-worktrees/chat-extraction`, run `uv run python -c "from chat_pipeline import resolve_paths, extract_audio_batch; print(resolve_paths())"` and `uv run python -c "from chat_pipeline import extract_audio_batch; print(type(extract_audio_batch([])).__name__)"` to confirm helpers import and return structured results.</verify>
  <done>Extraction stage supports both single and batch inputs, writes audio artifacts to the chat-extraction data directory, and logs per-file extraction failures without aborting the full batch run.</done>
</task>

<task type="auto">
  <name>Task 2: Implement local Whisper transcription with reusable schema outputs</name>
  <files>02-worktrees/chat-extraction/chat_pipeline.py, 02-worktrees/chat-extraction/chat-extraction.py, 02-worktrees/chat-extraction/pyproject.toml</files>
  <action>Add local transcription helpers using `faster-whisper` with configurable notebook model selection and quality-first defaults. Persist transcript checkpoints to `00-supporting-files/data/chat-extraction/transcripts/*.json` with stable schema: source media metadata, segment timestamps, word timestamps when available, and diarization speaker labels when feasible. Add best-effort diarization path (WhisperX/pyannote if installed/token available) and explicit fallback `speaker: "UNKNOWN"` when unavailable or low quality; log fallback reason in run metadata.</action>
  <verify>From `02-worktrees/chat-extraction`, run `uv run python -c "import chat_pipeline as cp; print(hasattr(cp, 'transcribe_audio_file'))"` and `uv run python -c "import json, pathlib; p=pathlib.Path('chat_pipeline.py'); print(p.exists())"`; then run a notebook transcription cell on one extracted audio file and confirm transcript JSON is written under `00-supporting-files/data/chat-extraction/transcripts/`.</verify>
  <done>Notebook can run local Whisper transcription and save reusable transcript JSON containing segment timestamps plus word-level timing fields and feasible speaker labels with documented fallback behavior.</done>
</task>

<task type="auto">
  <name>Task 3: Record run metadata and enforce stage checkpoint resumability</name>
  <files>02-worktrees/chat-extraction/chat_pipeline.py, 02-worktrees/chat-extraction/chat-extraction.py</files>
  <action>Add per-run metadata snapshots in `00-supporting-files/data/chat-extraction/runs/` including model names, transcription parameters, timing/duration, inputs processed, failures, and output artifact paths. Ensure notebook cells can resume from existing audio/transcript artifacts without re-running previous stages unless override flags are set.</action>
  <verify>Run notebook extraction/transcription twice on the same sample and confirm the second run reuses existing stage artifacts by default while writing a new run metadata entry with resume markers.</verify>
  <done>Each notebook run produces a machine-readable run record and supports idempotent stage reuse for iterative workflow without forced full reruns.</done>
</task>

</tasks>

<verification>
Execute one single-file run and one batch run from notebook cells; verify audio and transcript artifacts exist, structured logs capture extraction failures, and run metadata documents stage timings and fallback reasons.
</verification>

<success_criteria>
`CHAT-01` and `CHAT-02` are satisfied: notebook extraction works for local video inputs (single and batch), transcription runs locally with configurable Whisper model, and reusable transcript checkpoints are persisted for downstream segmentation.
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-extraction-notebook-pipeline/02-01-SUMMARY.md`
</output>
